./src/utils/constants.ts:
```ts
import { PublicKey } from "@solana/web3.js";

export const RPC_URL = "http://127.0.0.1:8899";
export const USDC_MINT = new PublicKey("5Tb4TJxgNYw69FCnJJH6b5cYV3fdezDk9BagML2ToXuN");
```

./src/utils/solana.ts:
```ts
```

./src/models/Investment.ts:
```ts
export interface Investment {
	publicKey: string;
	investor: string;
	property: string;
	amount: number;
	dividendsClaimed: number;
}

export interface InvestmentDatabase {
	id: string;
	investor_public_key: string;
	property_pda: string;
	created_at: string;
}
```

./src/models/Property.ts:
```ts
export interface Property {
	name: string;
	total_tokens: number;
	available_tokens: number;
	price_per_token: number;
	token_symbol: string;
	property_pda: string;
	creator_public_key: string;
	is_closed: boolean;
}

export interface PropertyDatabase {
	id: string;
	property_pda: string;
	creator_public_key: string;
	created_at: string;
}
```

./src/models/User.ts:
```ts
export enum Role {
	Investor = "investor",
	Landlord = "landlord",
}

export interface User {
	id: string;
	publicKey: string;
	name: string;
	role: Role;
}
```

./src/controllers/rpcController.ts:
```ts
import http from "http";
import dotenv from "dotenv";
import { handleLogin } from "./user/login";
import { handleCreateProperty } from "./program/createProperty";
import { handleRegister } from "./user/register";
import { handleListProperties } from "./program/listProperties";
import { handleListInvestments } from "./program/listInvestments";

dotenv.config();

interface JsonRpcRequest {
	jsonrpc: string;
	method: string;
	params: any;
	id: number | string | null;
}

interface JsonRpcResponse {
	jsonrpc: string;
	result?: any;
	error?: {
		code: number;
		message: string;
	};
	id: number | string | null;
}

async function getRequestBody(req: http.IncomingMessage): Promise<any> {
	return new Promise((resolve, reject) => {
		let body = "";
		req.on("data", (chunk) => {
			body += chunk.toString();
		});
		req.on("end", () => {
			try {
				const parsedBody = JSON.parse(body || "{}");
				resolve(parsedBody);
			} catch (error) {
				reject(error);
			}
		});
	});
}

export const handleRestRequest = async (
	req: http.IncomingMessage,
	res: http.ServerResponse
) => {
	if (!req.url || !req.method) {
		res.writeHead(400, { "Content-Type": "application/json" });
		res.end(JSON.stringify({ error: "Bad Request" }));
		return;
	}

	const parsedUrl = new URL(req.url, `http://${req.headers.host}`);
	const pathname = parsedUrl.pathname;

	switch (req.method) {
		case "GET":
			switch (pathname) {
				case "/health":
					res.writeHead(200, { "Content-Type": "application/json" });
					res.end(JSON.stringify({ status: "ok" }));
					break;
				default:
					res.writeHead(404, { "Content-Type": "application/json" });
					res.end(JSON.stringify({ error: "Not Found" }));
					break;
			}
			break;
		case "POST":
			try {
				const requestBody = await getRequestBody(req);
				switch (pathname) {
					case "/login":
						const loginResponse = await handleLogin(requestBody);
						res.writeHead(200, {
							"Content-Type": "application/json",
						});
						res.end(JSON.stringify(loginResponse));
						break;
					case "/register":
						const registerResponse = await handleRegister(
							requestBody
						);
						res.writeHead(201, {
							"Content-Type": "application/json",
						});
						res.end(JSON.stringify(registerResponse));
						break;
					case "/create-property":
						const createPropertyResponse =
							await handleCreateProperty(requestBody);
						res.writeHead(201, {
							"Content-Type": "application/json",
						});
						res.end(JSON.stringify(createPropertyResponse));
						break;
					case "/list-properties":
						console.log("List properties");
						try {
							const requestBody = await getRequestBody(req);
							const response = await handleListProperties(
								requestBody
							);
							res.writeHead(200, {
								"Content-Type": "application/json",
							});
							res.end(JSON.stringify(response));
						} catch (error: any) {
							res.writeHead(error.code || 500, {
								"Content-Type": "application/json",
							});
							res.end(
								JSON.stringify({
									error:
										error.message ||
										"Internal Server Error",
								})
							);
						}
						break;
					case "/list-investments":
						console.log("List investments");
						try {
							const investmentsResponse =
								await handleListInvestments(requestBody);
							res.writeHead(200, {
								"Content-Type": "application/json",
							});
							res.end(JSON.stringify(investmentsResponse));
						} catch (error: any) {
							res.writeHead(error.code || 500, {
								"Content-Type": "application/json",
							});
							res.end(
								JSON.stringify({
									error:
										error.message ||
										"Internal Server Error",
								})
							);
						}
						break;
					default:
						res.writeHead(404, {
							"Content-Type": "application/json",
						});
						res.end(JSON.stringify({ error: "Not Found" }));
						break;
				}
			} catch (error: any) {
				res.writeHead(error.code || 500, {
					"Content-Type": "application/json",
				});
				res.end(
					JSON.stringify({
						error: error.message || "Internal Server Error",
					})
				);
			}
			break;
		default:
			res.writeHead(405, { "Content-Type": "application/json" });
			res.end(JSON.stringify({ error: "Method Not Allowed" }));
			break;
	}
};
```

./src/controllers/user/login.ts:
```ts
import { z } from "zod";
import { User } from "../../models/User";
import redisClient from "../../services/redis";
import { supabase } from "../../services/supabase";

const createHandleLoginSchema = z.object({
	publicKey: z.string().nonempty(),
});

export const handleLogin = async (body: any) => {
	const parseResult = createHandleLoginSchema.safeParse(body);

	if (!parseResult.success) {
		throw {
			code: 400,
			message: "Invalid input parameters",
		};
	}

	const { publicKey } = parseResult.data;

	if (!publicKey) {
		throw { code: 400, message: "Missing publicKey parameter" };
	}

	let user: User | null = null;
	try {
		const cachedUser = await redisClient.get(`user:${publicKey}`);
		if (cachedUser) {
			user = JSON.parse(cachedUser);
			console.log("User found in Redis cache");
		} else {
			const { data, error } = await supabase
				.from("users")
				.select("*")
				.eq("public_key", publicKey)
				.single();

			if (error || !data) {
				console.error("Error fetching user from Supabase:", error);
				throw { code: 404, message: "User not found" };
			}

			user = {
				id: data.id,
				publicKey: data.public_key,
				name: data.name,
				role: data.role,
			};

			await redisClient.setEx(
				`user:${publicKey}`,
				60,
				JSON.stringify(user)
			);

			console.log("User found in Supabase and stored in Redis");
		}
	} catch (err: any) {
		if (err.code === 404) {
			throw { code: 404, message: "User not found" };
		}
		console.error("Error during login:", err);
		throw { code: 500, message: "Internal server error" };
	}

	return { user };
};
```

./src/controllers/user/register.ts:
```ts
import { z } from "zod";
import { Role } from "../../models/User";
import redisClient from "../../services/redis";
import { supabase } from "../../services/supabase";

const createHandleRegisterSchema = z.object({
	publicKey: z.string().min(32),
	name: z.string().min(1),
	role: z.enum([Role.Investor, Role.Landlord]),
});

export const handleRegister = async (body: any) => {
	const {
		data: { publicKey, name, role },
	} = createHandleRegisterSchema.safeParse(body);

	if (!publicKey || !name || !role) {
		throw { code: 400, message: "Missing parameters" };
	}

	try {
		const { data: existingUser, error } = await supabase
			.from("users")
			.select("*")
			.eq("public_key", publicKey)
			.single();

		if (existingUser) {
			throw { code: 409, message: "User already exists" };
		}
	} catch (err: any) {
		if (err.code === 409) {
			throw err;
		}
	}

	const { data, error } = await supabase
		.from("users")
		.insert([
			{
				public_key: publicKey,
				name,
				role: role || Role.Investor,
			},
		])
		.select("*")
		.single();

	if (error || !data) {
		console.error("Error registering user in Supabase:", error);
		throw { code: 500, message: "Failed to register user" };
	}

	const user = {
		id: data.id,
		publicKey: data.public_key,
		name: data.name,
		role: data.role,
	};

	try {
		await redisClient.setEx(
			`user:${publicKey}`,
			3600,
			JSON.stringify(user)
		);
	} catch (err) {
		console.error("Error storing user in Redis:", err);
	}

	return { user };
};
```

./src/controllers/program/listInvestments.ts:
```ts
import { program } from "../../services/crowd-estate";
import { PublicKey } from "@solana/web3.js";
import { z } from "zod";

const listInvestmentsSchema = z.object({
	publicKey: z.string().min(32),
});

export const handleListInvestments = async (body: any) => {
	const parseResult = listInvestmentsSchema.safeParse(body);
	if (!parseResult.success) {
		throw { code: 400, message: "Invalid input parameters" };
	}
	const { publicKey } = parseResult.data;

	try {
		const investorPublicKey = new PublicKey(publicKey);

		const fetchedInvestments = await program.account.investor.all();

		const investmentsData = fetchedInvestments
			.filter((investment) =>
				investment.account.investor.equals(investorPublicKey)
			)
			.map((investment) => ({
				publicKey: investment.publicKey.toBase58(),
				investor: investment.account.investor.toBase58(),
				property: investment.account.property.toBase58(),
				amount: investment.account.tokensOwned.toNumber(),
				dividendsClaimed:
					investment.account.dividendsClaimed.toNumber(),
			}));

		const fetchedProperties = await program.account.property.all();

		const properties = fetchedProperties.map((property) => ({
			publicKey: property.publicKey.toBase58(),
			price_per_token: property.account.tokenPriceUsdc.toNumber() / 1e6,
		}));

		let invested = 0;
		let returns = 0;

		investmentsData.forEach((investment) => {
			const property = properties.find(
				(p) => p.publicKey === investment.property
			);
			if (property) {
				invested += investment.amount * property.price_per_token;
				returns += investment.dividendsClaimed / 1e6;
			}
		});

		return { investmentsData, invested, returns };
	} catch (error) {
		console.error("Error fetching investments:", error);
		throw { code: 500, message: "Failed to fetch investments" };
	}
};
```

./src/controllers/program/listProperties.ts:
```ts
import { z } from "zod";
import { Property, PropertyDatabase } from "../../models/Property";
import { getProperties, getProperty } from "../../services/crowd-estate";
import redisClient from "../../services/redis";
import { supabase } from "../../services/supabase";

const fetchPropertiesFromRPC = async (
	propertyPda?: string
): Promise<Property[]> => {
	try {
		if (propertyPda) {
			const data = await getProperty(propertyPda);
			return [data];
		} else {
			const data = await getProperties();
			return data;
		}
	} catch (error) {
		console.error("Error fetching properties from RPC:", error);
		throw { code: 500, message: "Failed to fetch properties from RPC" };
	}
};

const updateSupabaseWithProperties = async (
	properties: Property[]
): Promise<void> => {
	try {
		const propertiesDatabase = properties.map((property) => ({
			property_pda: property.property_pda,
			creator_public_key: property.creator_public_key,
		}));

		const { data, error } = await supabase
			.from("properties")
			.upsert(propertiesDatabase, {
				onConflict: "property_pda",
			});

		if (error) {
			console.error("Error upserting properties to Supabase:", error);
			throw {
				code: 500,
				message: "Failed to update properties in database",
			};
		}

		console.log("Supabase properties updated successfully");
	} catch (error) {
		console.error("Error updating Supabase:", error);
		throw error;
	}
};

export enum Filters {
	ALL = "ALL",
	OPEN = "OPEN",
	CLOSED = "CLOSED",
	USER = "USER",
}

const handleListPropertiesSchema = z.object({
	filters: z.array(z.nativeEnum(Filters)).optional(),
	userPublicKey: z.string().min(32).optional(),
});

export const handleListProperties = async (
	body: any
): Promise<{
	properties: Property[];
}> => {
	const parseResult = handleListPropertiesSchema.safeParse(body);

	if (!parseResult.success) {
		throw {
			code: 400,
			message: "Invalid input parameters",
		};
	}

	const { filters, userPublicKey } = parseResult.data;

	try {
		const properties = await getProperties(filters, userPublicKey);

		await redisClient.setEx("properties", 3600, JSON.stringify(properties));

		return { properties };
	} catch (error: any) {
		console.error("Error handling list properties:", error);
		throw {
			code: error.code || 500,
			message: error.message || "Internal server error",
		};
	}
};
```

./src/controllers/program/createProperty.ts:
```ts
import { Property } from "../../models/Property";
import { User } from "../../models/User";
import { verifyProperty } from "../../services/crowd-estate";
import redisClient from "../../services/redis";
import { supabase } from "../../services/supabase";
import { z } from "zod";

const createPropertySchema = z.object({
	userPublicKey: z.string().min(32),
	propertyPda: z.string().min(32),
});

export const handleCreateProperty = async (
	body: any
): Promise<{
	property: Property;
}> => {
	const parseResult = createPropertySchema.safeParse(body);
	if (!parseResult.success) {
		throw { code: 400, message: "Invalid input parameters" };
	}
	const { userPublicKey, propertyPda } = parseResult.data;

	try {
		await verifyProperty(propertyPda);

		if (!userPublicKey || !propertyPda) {
			throw { code: 400, message: "Missing parameters" };
		}

		let user: User | null = null;
		let { data: userData, error: userError } = await supabase
			.from("users")
			.select("*")
			.eq("public_key", userPublicKey)
			.single();
		console.log("userData", userData);
		console.log("error", userError);

		if (userError || !userData) {
			console.error("User not found:", userError);
			throw { code: 404, message: "User not found" };
		}

		user = userData as User;

		if (user.role !== "landlord") {
			throw {
				code: 403,
				message: "User is not authorized to create properties",
			};
		}

		let { data: existingProperty } = await supabase
			.from("properties")
			.select("*")
			.eq("property_pda", propertyPda)
			.single();

		if (existingProperty) {
			throw { code: 409, message: "Property already exists" };
		}

		const { data: propertyData, error } = await supabase
			.from("properties")
			.insert([
				{
					property_pda: propertyPda,
					creator_public_key: userPublicKey,
				},
			])
			.select("*")
			.single();

		if (error || !propertyData) {
			console.error("Error inserting property:", error);
			throw { code: 500, message: "Failed to create property" };
		}

		const property: Property = propertyData;

		await redisClient.setEx(
			`property:${propertyPda}`,
			3600,
			JSON.stringify(property)
		);
		console.log("Property cached in Redis");

		await redisClient.del("properties");
		console.log("Properties cache invalidated");

		return { property };
	} catch (err: any) {
		console.error("Error creating property:", err);
		throw {
			code: err.code || 500,
			message: err.message || "Failed to create property",
		};
	}
};
```

./src/server.ts:
```ts
import http from "http";
import dotenv from "dotenv";
import { handleRestRequest } from "./controllers/rpcController";

dotenv.config();

const server = http.createServer(async (req, res) => {
	res.setHeader("Access-Control-Allow-Origin", "*");
	res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
	res.setHeader(
		"Access-Control-Allow-Headers",
		"Content-Type, Authorization"
	);
	res.setHeader("Access-Control-Allow-Credentials", "true");

	if (req.method === "OPTIONS") {
		res.writeHead(204);
		res.end();
		return;
	}

	if (req.method === "GET" && req.url === "/health") {
		res.writeHead(200, { "Content-Type": "application/json" });
		res.end(JSON.stringify({ status: "OK" }));
		return;
	}

	if (req.method === "GET" || req.method === "POST") {
		await handleRestRequest(req, res);
	} else {
		res.writeHead(404, { "Content-Type": "application/json" });
		res.end(JSON.stringify({ error: "Not Found" }));
	}
});

const PORT: number = parseInt(process.env.PORT || "5500");
server.listen(PORT, () => {
	console.log(`Server is running on port ${PORT}`);
});
```

./src/services/crowd-estate.ts:
```ts
import * as anchor from "@coral-xyz/anchor";
import { CrowdEstate } from "../../../../target/types/crowd_estate";
import IDL from "../../../../target/idl/crowd_estate.json";
import { Connection, Keypair } from "@solana/web3.js";
import { Wallet } from "@coral-xyz/anchor";
import { Property } from "../models/Property";
import { Filters } from "../controllers/program/listProperties";

const admKeypairBytesString = process.env.ADM!;
if (!admKeypairBytesString) {
	throw new Error("Missing ADM");
}
const admKeypairBytes = Uint8Array.from(JSON.parse(admKeypairBytesString));

const endpoint = "https://api.devnet.solana.com";
const connection = new Connection(endpoint);
const walletKeypair = Keypair.fromSecretKey(admKeypairBytes);
const wallet = new Wallet(walletKeypair);
const provider = new anchor.AnchorProvider(connection, wallet, {
	preflightCommitment: "processed",
});
const program = new anchor.Program<CrowdEstate>(IDL as CrowdEstate, provider);

export const verifyProperty = async (
	propertyPda: string
): Promise<Property> => {
	const property = await getProperty(propertyPda);
	return property;
};

export const getProperties = async (
	filters: Filters[] = [Filters.ALL],
	userPublicKey?: string
): Promise<Property[]> => {
	const fetchedProperties = await program.account.property.all();
	console.log(fetchedProperties);

	let propertiesData: Property[] = fetchedProperties.map((property) => ({
		name: Buffer.from(property.account.propertyName).toString().trim(),
		total_tokens: property.account.totalTokens.toNumber(),
		available_tokens: property.account.availableTokens.toNumber(),
		price_per_token: property.account.tokenPriceUsdc.toNumber() / 1e6,
		token_symbol: Buffer.from(property.account.tokenSymbol)
			.toString()
			.trim(),
		property_pda: property.publicKey.toBase58(),
		creator_public_key: property.account.admin.toBase58(),
		is_closed: property.account.isClosed,
	}));

	propertiesData = propertiesData.filter((property) => {
		for (const filter of filters) {
			if (filter === Filters.ALL) {
				return true;
			} else if (filter === Filters.OPEN && property.is_closed) {
				return false;
			} else if (filter === Filters.CLOSED && !property.is_closed) {
				return false;
			} else if (
				filter === Filters.USER &&
				property.creator_public_key !== userPublicKey
			) {
				return false;
			}
		}
		return true;
	});

	return propertiesData;
};

export const getProperty = async (propertyPda: string): Promise<Property> => {
	const propertyAccount = await program.account.property.fetchNullable(
		propertyPda
	);

	if (!propertyAccount) {
		throw { code: 404, message: `Property ${propertyPda} not found` };
	}

	const property: Property = {
		name: Buffer.from(propertyAccount.propertyName).toString().trim(),
		total_tokens: propertyAccount.totalTokens.toNumber(),
		price_per_token: propertyAccount.tokenPriceUsdc.toNumber() / 1e6,
		token_symbol: Buffer.from(propertyAccount.tokenSymbol)
			.toString()
			.trim(),
		property_pda: propertyPda,
		available_tokens: propertyAccount.availableTokens.toNumber(),
		creator_public_key: propertyAccount.admin.toBase58(),
		is_closed: propertyAccount.isClosed,
	};

	return property;
};

export { program, provider };
```

./src/services/redis.ts:
```ts
import { createClient } from "redis";
import dotenv from "dotenv";

dotenv.config();

const redisClient = createClient({
    url: process.env.REDIS_URL || "redis://localhost:6379",
});

redisClient.on("error", (err) => console.error("Redis Client Error", err));

(async () => {
    try {
        await redisClient.connect();
        console.log("Connected to Redis");
    } catch (err) {
        console.error("Error connecting to Redis:", err);
    }
})();

export default redisClient;```

./src/services/supabase.ts:
```ts
import { createClient } from "@supabase/supabase-js";

export const supabase = createClient(
	process.env.SUPABASE_URL!,
	process.env.SUPABASE_KEY!
);
```

